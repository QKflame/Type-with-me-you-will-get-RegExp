# 学会正则表达式

参考链接：https://www.zhihu.com/question/48219401/answer/742444326

## 正则基础知识点

### 1. 元字符

元字符是构造正则表达式的一种基本元素。

下面是几个常用的元字符：

| 元字符 | 说明                         |
| ------ | ---------------------------- |
| .      | 匹配除换行符以外的任意字符   |
| \w     | 匹配字母或数字或下划线或汉字 |
| \s     | 匹配任意的空白字符           |
| \d     | 匹配数字                     |
| \b     | 匹配单词的开始或结束         |
| ^      | 匹配字符串的开始             |
| $      | 匹配字符串的结束             |

用上面的元字符写一些简单的正则表达式：

1. 匹配有 abc 开头的字符串

   ```js
   const reg = /\babc/
   ```

   或

   ```js
   const reg = /^abc/
   ```

2. 匹配 8 位数字的 QQ 号码

   ```js
   const reg = /^\d\d\d\d\d\d\d\d$/
   ```

3. 匹配1开头11位数字的手机号码

   ```js
   const reg = /^1\d\d\d\d\d\d\d\d\d\d$/
   ```



### 2. 重复限定符

有了元字符就可以写很多正则表达式了，但是如果想书写的正则表达式更加简单明了，就需要用到正则表达式中的重复限定符，把重复部分用合适的限定符替代。

下面是一些限定符：

| 语法  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

有了这些限定符，我们就能对之前的正则表达式进行改造了，比如：

1. 匹配8位数字的QQ号码：

   ```js
   const reg = /^\d{8}$/
   ```

2. 匹配1开头的11位数字的手机号码：

   ```js
   const reg = /^1\d{10}$/
   ```

3. 匹配银行卡号是 14-18位的数字：

   ```js
   const reg = /^\d{14,18}$/
   ```

4. 匹配以 a 开头，0个或多个b结尾的字符串

   ```js
   const reg = /^ab*/
   ```



### 3. 分组

从上面的 （4）的例子可以看出，*限定符是作用在与它左边最近的一个字符，那么问题来了，如果我想ab同时被***** 限定怎么办呢？

**正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。**

因此，当我们要匹配多个 ab 是，我们可以这样写：

如：匹配字符串中包含 0 到 多个 ab 开头

```js
const reg = /^(ab)*/
```



### 4. 转义

我们看到正则表达式用小括号来分组，那么问题来了：

**如果要匹配的字符串本身就包含小括号，那是不是冲突？应该怎么办？**

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简单，就是要在转移的字符前面加个斜杠，也就是 \ 即可。

如：要匹配以（ab）开头：

```js
const reg = /^(\(ab\))/
```



### 5. 条件或

回到刚才的手机号匹配，我们都知道，国内号码都来自三大网，它们都有属于自己的号段，比如联通有 132，131,132,155,156,185,186,145,176 等号段，假如让我们匹配一个联通的号码，那么按照我们目前所学到的正则，应该是无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

> 正则用符号 ``|`` 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们可以用 或 条件来处理这个问题：

```js
const reg = /^(130|131|132|155|156|185|186|145|176)\d{8}/
```



### 6. 区间

看到上面的例子，是不是看到有什么规律呢？是不是还有一种想要简化的冲动？

实际是有的。

> 正则提供一个元字符中括号[]来表示区间条件。

1. 限定0-9，可以写成 [0-9]
2. 限定A-Z，可以写成 [A-Z]
3. 限定某些数字可以写成 [165]

那上面的正则我们还改成这样：

```js
const reg = /^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$/
```

正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但又看不下去文档的人做一个快速入门的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看的懂别人写的正则了。



## 正则进阶知识点

### 1. 零宽断言

> 无论是零宽还是断言，听起来都古古怪怪的，
>
> 那先解释一下这两个词。

1. 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在在指定的内容的前面或后面会出现满足指定规则的内容。

   意思是正则也可以像人类那样断定什么什么，比如“ss1aa2bb3”， 正则可以用断言找出 aa2 前面有 bb3 ，也可以找出 aa2 后面有 ss1.

2. 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会有断言本身。

意思是讲明白了，那它有什么用呢？

我们来举个栗子：

假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构：

```txt
"<span class="read-count">阅读量：641</span>"
```

也就是 ``641`` ，这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里面的 ``641`` 有很多办法，但是如果用正则应该怎么匹配呢？

下面先来讲几种类型的断言：

1. 正向先行断言（正前瞻）

   - 语法：（?=pattern）
   - 作用：匹配 pattern 表达式的前面内容，不返回本身。

   这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正在表达式中意味着要匹配到 ``<\span>`` 的前面的数字内容。

   按照上面所说的正向先行断言可以匹配表达式前面的内容，那意思就是：``(?=</span>)`` 就可以匹配到前面的内容了。

   匹配什么内容呢？如果要所有内容那就是：

   ```js
   const str = '<span class="read-count">阅读量：641</span>'
   const reg = /.+(?=<\/span>)/
   let result = str.match(reg)
   console.log(result)
   ```

   结果是：

   ```js
   [ '<span class="read-count">阅读量：641',
     index: 0,
     input: '<span class="read-count">阅读量：641</span>',
     groups: undefined ]
   ```

   显然，数字的第一项就是匹配到的结果。

   可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字\d，那可以改成：

   ```js
   const str = '<span class="read-count">阅读量：641</span>'
   const reg = /\d+(?=<\/span>)/
   let result = str.match(reg)
   console.log(result)
   ```

   结果是：

   ```js
   641
   ```

   大功告成！

2. 正向后行断言（正后顾）：

   - 语法：（?<=pattern）
   - 作用：匹配 pattern 表达式的后面的内容，不返回本身。

   有先行就有后行，先行是匹配前面的内容，那就是匹配后面的内容啦。

   上面的栗子，我们也可以用后行断言来处理。

   ```js
   const str = '<span class="read-count">阅读量：641</span>'
   const reg = /(?<=<span class="read-count">阅读量：)\d+/
   let result = str.match(reg)
   console.log(result)
   ```

   结果：

   ```js
   641
   ```

   就是这么简单！

3. 负向先行断言（负前瞻）

   - 语法：（?!pattern）
   - 作用：匹配非pattern表达式的前面内容，不返回本身。
   
   有正向也有负向，负向在这里其实就是非的意思。
   
   举个栗子：比如有一句“我爱祖国，我是祖国的花朵”。
   
   现在要找到不是``的花朵`` 前面的祖国。
   
   用正则就可以这样写：
   
   ```js
   const reg = 祖国(?!的花朵)
   ```
   
4. 负向后行断言（负后顾）

   - 语法：（?<!pattern）
   - 作用：匹配非 pattern 表达式的后面内容，不返回本身。



### 2. 捕获与非捕获

单独说到捕获，它的意思是匹配表达式，但捕获通常和分组联系在一起，也就是 ``捕获组``。

> 捕获组（capture group）：匹配子表达式的内容，把匹配结果保存到内存中以数字编号或显式命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

而根据命名方式的不同，又可以分为两种组：

1. 数字编号捕获组：

   语法：(exp)

   解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。

   比如固定电话的：020-85653333

   它的正则表达式为：(0\d{2})-(\d{8})

   按照左括号的顺序，这个表达式有如下分组：

   | 序号 | 编号 | 分组             | 内容         |
   | ---- | ---- | ---------------- | ------------ |
   | 0    | 0    | (0\d{2})-(\d{8}) | 020-85653333 |
   | 1    | 1    | (0\d{2})         | 020          |
   | 2    | 2    | (\d{8})          | 86653333     |

   我们来用 js 来验证一下：

   ```js
   const str = '020-85653333'
   const reg = /(0\d{2})-(\d{8})/
   let result = str.match(reg)
   console.log(result)
   ```

   输出结果：

   ```js
   [ '020-85653333',       
     '020',
     '85653333',
     index: 0,
     input: '020-85653333',
     groups: undefined ]
   ```

   一共有三个分组，第0个分组就是整个表达式本身。

2. 命名编号捕获分组

   语法：(?<name>exp)

   解释：分组的命名由表达式中的name指定

   比如区号也可以这样写：(?<quhao>\0\d{2})-(?<haoma>\d{8})

   按照左括号的顺序，这个表达式有如下分组：

   | 序号 | 名称  | 分组             | 内容         |
   | ---- | ----- | ---------------- | ------------ |
   | 0    | 0     | (0\d{2})-(\d{8}) | 020-85653333 |
   | 1    | quhao | (0\d{2})         | 020          |
   | 2    | haoma | (\d{8})          | 86653333     |

   用代码来验证一下：

   ```js
   const str = '020-85653333'
   const reg = /(?<quhao>0\d{2})-(?<haoma>\d{8})/
   let result = reg.exec(str)
   console.log(result)
   ```

   输入结果：

   ```js
   [ '020-85653333',
     '020',
     '85653333',
     index: 0,
     input: '020-85653333',
     groups: [Object: null prototype] { quhao: '020', haoma: '85653333' } ]
   ```

3. 非捕获组

   语法：(?:exp)

   解释：和捕获组刚好相反，它用来表示那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。

   比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：

   ```js
   const reg = /(?:0\d{2})-(\d{8})/
   ```

   分组如下：

   | 序号 | 编号 | 分组             | 内容         |
   | ---- | ---- | ---------------- | ------------ |
   | 0    | 0    | (0\d{2})-(\d{8}) | 020-85653333 |
   | 1    | 1    | (\d{8})          | 85653333     |

   用程序验证一下：

   ```js
   const str = '020-85653333'
   const reg = /(?:0\d{2})-(\d{8})/
   let result = reg.exec(str)
   console.log(result)
   ```

   输入结果：

   ```js
   [ '020-85653333',
     '85653333',
     index: 0,
     input: '020-85653333',
     groups: undefined ]
   ```

### 3.反向引用

上面讲到捕获，我们知道：**捕获会返回一个捕获组，这个分组是保存在内存中的，不仅可以在正则表达式外部通过程序引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。**

根据捕获组的命名规则，反向引用可分为：

1. 数字编号组反向引用：``\k`` 或 ``\number``
2. 命名编号组反向引用：``\k`` 或 ``\name``

好了，讲完了，懂吗？不懂！！！

可能连前面讲的捕获有什么用都还不懂吧？

其实只是看完捕获不懂不会用是很正常的！

因为捕获组通常是和反向引用一起使用的。



上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。

注意两个字眼：**"内容"** 和 **"使用"**

这里所说的"内容",是匹配结果，而不是子表达式本身，强调这个有什么用呢？恩，先记住这里所说的“使用”是怎样使用呢？

因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。



这样举例子吧：

比如要查找一串字母“aabbbbgbddesddfiid”里成对的字母

如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的。

现在我们先用程序思维理一下思路：

- 1）匹配到一个字母；
- 2）匹配下一个字母，检查是否和上一个字母一样
- 3）如果一样，则匹配成功，否则失败

这里的思路2中匹配到下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？

这下子捕获就有用处了，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件好了，有思路就要有实践。

首先匹配一个字母：**\w**

我们需要做成分组才能捕获，因此写成这样：**（\w）**

那这个表达式就有一个捕获组：**(\w)**

然后我们要用这个捕获组作为条件，那就可以：**(\w)\1**

这样就大功告成了！

可能有人不明白了，**\1** 是什么意思？

还记得捕获组有两种命名方式吗，**一种是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名**

**在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的。**

因此要引用第一个捕获组，根据反向引用的数字命名规则就需要 **\k<1>** 或 **\1**。

当然，通常都是使用后者。

我们来测试一下：

```js
const str = "aabbbbgbddesddfiid"

const reg = /(\w)\1/g

let result = str.match(reg)

console.log(result)
```

输出结果：

```js
[ 'aa', 'bb', 'bb', 'dd', 'dd', 'ii' ]
```

恩，这就是我们想要的了。

再举个替换的栗子，假如想要把字符串中 abc 替换成 a：

```js
const str = "abcbbabcbcgbddesddfiid"

const reg = /(a)(b)c/g

let result = str.replace(reg, '$1')

console.log(result)
```

输出结果：

```js
abbabcgbddesddfiid
```



